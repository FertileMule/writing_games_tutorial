Let's start with a very simple example of a game. This will be a game in which
a monkey's face travels back and forth across the screen, and the player must
try to "punch" the monkey by clicking on it. The gameplay will be familiar to
anyone who has gone through the "Chimp Line by Line" [TODO: link] tutorial or
those who have endured annoying banner ads in the early 2000s.

----
import time
import pygame
import pygame.constants as c

score = 0

screenDimensions = pygame.Rect((0,0,400,60))

black = (0,0,0)
white = (255,255,255)
blue  = (0,0,255)
red   = (255,0,0)

class Monkey(pygame.sprite.Sprite):
    def __init__(self):
        self.stunTimeout = None
        self.velocity = 2
        super(Monkey, self).__init__()
        self.image = pygame.Surface((60,60))
        self.rect = self.image.get_rect()
        self.render(blue)

    def render(self, color):
        '''draw onto self.image the face of a monkey in the specified color'''
        self.image.fill(color)
        pygame.draw.circle(self.image, white, (10,10), 10, 2)
        pygame.draw.circle(self.image, white, (50,10), 10, 2)
        pygame.draw.circle(self.image, white, (30,60), 20, 2)

    def attemptPunch(self, pos):
        '''If the given position (pos) is inside the monkey's rect, the monkey
        has been "punched".  A successful punch will stun the monkey and increment
        the global score.  The monkey cannot be punched if he is already stunned
        '''
        if self.stunTimeout:
            return # already stunned
        if self.rect.collidepoint(pos):
            # Argh!  The punch intersected with my face!
            self.stunTimeout = time.time() + 2 # 2 seconds from now
            global score
            score += 1
            self.render(red)

    def update(self):
        if self.stunTimeout:
            # If stunned, the monkey doesn't move
            if time.time() > self.stunTimeout:
                self.stunTimeout = None
                self.render(blue)
        else:
            # Move the monkey
            self.rect.x += self.velocity
            # Don't let the monkey run past the edge of the viewable area
            if self.rect.right > screenDimensions.right:
                self.velocity = -2
            elif self.rect.left < screenDimensions.left:
                self.velocity = 2

def main():
    # Necessary Pygame set-up...
    pygame.init()
    clock = pygame.time.Clock()
    displayImg = pygame.display.set_mode(screenDimensions.size)

    monkey = Monkey()

    while True:
        clock.tick(60) # aim for 60 FPS
        for event in pygame.event.get():
            if event.type == c.QUIT:
                return
            elif event.type == c.MOUSEBUTTONDOWN:
                monkey.attemptPunch(event.pos)

        monkey.update()
        displayImg.fill(black)
        displayImg.blit(monkey.image, monkey.rect)
        pygame.display.flip()

if __name__ == '__main__':
    main()
    print 'Your score was', score


----
So with that we have a (very simple, but complete) game. It may not be the most
fun game ever written, but that can be fixed by slick box art and a major motion
picture tie-in. Let's not concern ourselves with that and instead look at
the technical details.

What we have above is a minimal game. As we add features to it, the code will
grow in complexity. As humans, we are bad at holding and manipulating complex
systems in our brains. 

Consider what would happen if instead of just punching one monkey, we wanted to set
traps for 3 monkeys. A click of the mouse would either drop down a trap at the
clicked location or reset a sprung trap if one was already there. What might
our main() function look like?

----
def main():
    # Necessary Pygame set-up...
    pygame.init()
    clock = pygame.time.Clock()
    displayImg = pygame.display.set_mode(screenDimensions.size)

    monkeys = [Monkey(), Monkey(), Monkey()]
    traps = [Trap(), Trap(), Trap()]
    trapPointer = 0

    while True:
        clock.tick(60) # aim for 60 FPS
        for event in pygame.event.get():
            if event.type == c.QUIT:
                return
            elif event.type == c.MOUSEBUTTONDOWN:
                wasTrapClick = False
                for trap in traps:
                    if trap.rect.collidepoint(event.pos):
                        trap.reset()
                        wasTrapClick = True
                        break
                if not wasTrapClick:
                    trap = traps[trapPointer]
                    trapPointer += 1
                    trapPointer %= len(traps)

        for monkey in monkeys:
            monkey.update(traps)
        displayImg.fill(black)
        displayImg.blit(monkey.image, monkey.rect)
        pygame.display.flip()

----
So what happened?  Significantly, the block of code that starts with 
"for event in pygame.event.get():" has grown.  I'm going to call this the event
handling block.  Now it's about 10 lines longer.  It contains one new loop, 
and two new branches (if statements). Imagine what will happen to
the event handling block as each new feature is added.

Because we humans have trouble with complex systems, we have developed the techniques of organization and abstraction.
We organize things so that we only need to deal with one thing at a time, and
we abstract things so that we can manipulate a simple system that is "similar
enough" to the complex system.


