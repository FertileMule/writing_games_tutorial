Let's start with a very simple example of a game. This will be a game in which
a monkey's face travels back and forth across the screen, and the player must
try to "punch" the monkey by clicking on it. The gameplay will be familiar to
anyone who has gone through the "Chimp Line by Line" [TODO: link] tutorial or
those who have endured annoying banner ads in the early 2000s.

----
import time
import pygame
import pygame.constants as c

score = 0

screenDimensions = pygame.Rect((0,0,400,60))

black = (0,0,0)
white = (255,255,255)
blue  = (0,0,255)
red   = (255,0,0)

class Monkey(pygame.sprite.Sprite):
    def __init__(self):
        self.stunTimeout = None
        self.velocity = 2
        super(Monkey, self).__init__()
        self.image = pygame.Surface((60,60))
        self.rect = self.image.get_rect()
        self.render(blue)

    def render(self, color):
        '''draw onto self.image the face of a monkey in the specified color'''
        self.image.fill(color)
        pygame.draw.circle(self.image, white, (10,10), 10, 2)
        pygame.draw.circle(self.image, white, (50,10), 10, 2)
        pygame.draw.circle(self.image, white, (30,60), 20, 2)

    def attemptPunch(self, pos):
        '''If the given position (pos) is inside the monkey's rect, the monkey
        has been "punched".  A successful punch will stun the monkey and increment
        the global score.  The monkey cannot be punched if he is already stunned
        '''
        if self.stunTimeout:
            return # already stunned
        if self.rect.collidepoint(pos):
            # Argh!  The punch intersected with my face!
            self.stunTimeout = time.time() + 2 # 2 seconds from now
            global score
            score += 1
            self.render(red)

    def update(self):
        if self.stunTimeout:
            # If stunned, the monkey doesn't move
            if time.time() > self.stunTimeout:
                self.stunTimeout = None
                self.render(blue)
        else:
            # Move the monkey
            self.rect.x += self.velocity
            # Don't let the monkey run past the edge of the viewable area
            if self.rect.right > screenDimensions.right:
                self.velocity = -2
            elif self.rect.left < screenDimensions.left:
                self.velocity = 2

def main():
    # Necessary Pygame set-up...
    pygame.init()
    clock = pygame.time.Clock()
    displayImg = pygame.display.set_mode(screenDimensions.size)

    monkey = Monkey()

    while True:
        clock.tick(60) # aim for 60 frames per second
        for event in pygame.event.get():
            if event.type == c.QUIT:
                return
            elif event.type == c.MOUSEBUTTONDOWN:
                monkey.attemptPunch(event.pos)

        monkey.update()
        displayImg.fill(black)
        displayImg.blit(monkey.image, monkey.rect)
        pygame.display.flip()

if __name__ == '__main__':
    main()
    print 'Your score was', score


----
So with that we have a (very simple, but complete) game. It may not be the most
fun game ever written, but that can be fixed by slick box art and a major motion
picture tie-in. Let's leave those concerns for the marketing department and 
instead look at the technical details.

What we have above is a minimal game. As we add features to it, the code will
grow in complexity. As humans, we are bad at holding and manipulating complex
systems in our brains. 

Consider what would happen if instead of just punching one monkey, we wanted to set
traps for 3 monkeys. A click of the mouse would either drop down a trap at the
clicked location or reset a sprung trap if one was already there. What might
our main() function look like?

----
def main():
    # Necessary Pygame set-up...
    pygame.init()
    clock = pygame.time.Clock()
    displayImg = pygame.display.set_mode(screenDimensions.size)

    monkeys = [Monkey(), Monkey(), Monkey()]
    traps = [Trap(), Trap(), Trap()]
    trapCycle = itertools.cycle(traps)

    while True:
        clock.tick(60) # aim for 60 FPS
        for event in pygame.event.get():
            if event.type == c.QUIT:
                return
            elif event.type == c.MOUSEBUTTONDOWN:
                wasTrapClick = False
                for trap in traps:
                    if trap.rect.collidepoint(event.pos):
                        trap.reset()
                        wasTrapClick = True
                        break
                if not wasTrapClick:
                    # if the user didn't click on a trap, then they
                    # intended to place the next one here.
                    trap = trapCycle.next()
                    trap.place_at(event.pos)

        for monkey in monkeys:
            monkey.update(traps)
        displayImg.fill(black)
        displayImg.blit(monkey.image, monkey.rect)
        pygame.display.flip()

----
So what happened?  Significantly, the block of code that starts with 
"for event in pygame.event.get():" has grown.  I'm going to call this the event
handling block.  Now it's about 10 lines longer.  It contains one new loop, 
and two new branches (if statements). Imagine what will happen to
the event handling block as each new feature is added.  If your imagination
is summoning images of a single skyscraping ladder of an if / elif, ridden with
deep sub-blocks of loops and branches, countless and tentacle-like, then you
are two things: accurate, and likely on the same medication as myself.

Not only will complex code be difficult to hold in our brain, it also gets
in the way of our critical goal - Rapid Development. Developing software always
involves going back to code you've written in the past to make changes. If the
code is complex, you are going to pay greater time costs for both searching 
for the code to change, and for the change itself because it will need to be
made in more places.

Because we humans have trouble with complex systems, we have developed 
the techniques of organization and abstraction.
We organize so that we only need to deal with one thing at a time, and
we abstract so that we can manipulate a simple system that is "similar
enough" to the complex system.

How can we organize and/or abstract this code to address the problem of
growing complexity as we add more game features? (And while we're solving
that, can we also do ourselves some favours along the way to make it faster
to develop our game?)


